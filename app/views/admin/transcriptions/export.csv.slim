
- if @transcriptions.present? && @transcriptions.any? && @page_type.present?
  - headers = %w[date time]
  - @page_type.field_groups.each do |group|
    - headers = headers.concat(group.fields.map(&:field_key))
  - headers = headers.concat(%w[transcription_id page_id user_id first_started last_updated])
  / = CSV.generate_line(headers, encoding: 'UTF-8')
  - csv_string = CSV.generate(encoding: 'UTF-8') do |csv|
    - csv << headers
    - @transcriptions.each do |transcription|
      - dates = transcription.annotations.with_dimensions.order_by_date.group_by do |a|
        - a.observation_date.utc.to_date
      - dates.each do |date, date_annotations|
        - times = date_annotations.group_by { |a| a.observation_date.utc }
        - times.each do |time, time_annotations|
          - row = [date.to_s, time.strftime('%H:%M')]
          - created = nil
          - updated = nil
          - @page_type.field_groups.each do |group|
            - annotation = time_annotations.select{|a| a.field_group == group}.first
            - created = annotation.created_at if annotation && (created.nil? || annotation.created_at < created)
            - updated = annotation.updated_at if annotation && (updated.nil? || annotation.updated_at > updated)
            - group.fields.each do |field|
              - entry = nil
              - entry = transcription.data_entries.find_by(field_id: field.id, annotation_id: annotation.id) if annotation
              - value = nil
              - value = entry.value.html_safe if entry.present? && entry.value.present?
              - row << value
          - row = row.concat([transcription.id, transcription.page_id, transcription.user_id, (created ? created.strftime('%Y-%m-%d %H:%M') : nil), (updated ? updated.strftime('%Y-%m-%d %H:%M') : nil)])
          - csv << row
  = csv_string.html_safe
